#!/usr/bin/env python3
"""Verify that the TiDB test container is ready for Hibernate ORM runs."""

from __future__ import annotations

import argparse
import os
import shutil
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Optional, Sequence

from env_utils import load_lab_env, require_path, resolve_workspace_dir


class Logger:
    """Simple colorized logger mirroring the legacy Bash output."""

    BLUE = "\033[0;34m"
    GREEN = "\033[0;32m"
    YELLOW = "\033[1;33m"
    RED = "\033[0;31m"
    RESET = "\033[0m"

    def __init__(self) -> None:
        self._color = sys.stdout.isatty()

    def _fmt(self, label: str, color: str) -> str:
        if not self._color:
            return label
        return f"{color}{label}{self.RESET}"

    def info(self, message: str) -> None:
        print(f"{self._fmt('[INFO]', self.BLUE)} {message}")

    def success(self, message: str) -> None:
        print(f"{self._fmt('[OK]  ', self.GREEN)} {message}")

    def warning(self, message: str) -> None:
        print(f"{self._fmt('[WARN]', self.YELLOW)} {message}")

    def error(self, message: str) -> None:
        print(f"{self._fmt('[ERR]', self.RED)} {message}")

    def section(self, title: str) -> None:
        bar = "â•" * 56
        print("")
        print(self._fmt(bar, self.BLUE))
        print(self._fmt(f"  {title}", self.BLUE))
        print(self._fmt(bar, self.BLUE))
        print("")


class Runner:
    """Subprocess facade for easier testing."""

    def run(self, cmd: Sequence[str], **kwargs) -> subprocess.CompletedProcess[str]:
        kwargs.setdefault("text", True)
        return subprocess.run(cmd, **kwargs)


@dataclass
class VerifyOptions:
    bootstrap_sql: Optional[Path] = None


@dataclass
class VerifyEnvironment:
    scripts_dir: Path
    workspace_root: Path
    workspace: Path
    verify_project_dir: Path
    tidb_container: str
    runner_image: str


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Validate a running TiDB container using the verify_tidb helper project.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "--bootstrap",
        type=Path,
        help="Optional bootstrap SQL file generated by patch_docker_db_tidb.py",
    )
    return parser


def parse_options(argv: Optional[Sequence[str]] = None) -> VerifyOptions:
    args = build_parser().parse_args(argv)
    return VerifyOptions(bootstrap_sql=args.bootstrap)


def load_environment() -> VerifyEnvironment:
    load_lab_env(required=("WORKSPACE_DIR",))
    workspace_root = require_path("WORKSPACE_DIR")
    workspace = resolve_workspace_dir(workspace_root)
    scripts_dir = Path(__file__).resolve().parent
    verify_project_dir = scripts_dir / "verify_tidb"
    tidb_container = os.environ.get("TIDB_CONTAINER_NAME", "tidb")
    runner_image = os.environ.get("VERIFY_TIDB_RUNNER_IMAGE", "eclipse-temurin:21-jdk")
    return VerifyEnvironment(
        scripts_dir=scripts_dir,
        workspace_root=workspace_root,
        workspace=workspace,
        verify_project_dir=verify_project_dir,
        tidb_container=tidb_container,
        runner_image=runner_image,
    )


class VerifyTidbOrchestrator:
    def __init__(
        self,
        options: VerifyOptions,
        env: VerifyEnvironment,
        *,
        runner: Optional[Runner] = None,
        logger: Optional[Logger] = None,
    ) -> None:
        self.options = options
        self.env = env
        self.runner = runner or Runner()
        self.logger = logger or Logger()
        self.gradle_root: Optional[Path] = None
        self.bootstrap_sql: Optional[Path] = None

    def execute(self) -> None:
        self.logger.section("TiDB Verification")
        self.validate_inputs()
        self.run_verification()
        self.logger.success("TiDB verification completed successfully.")

    def validate_inputs(self) -> None:
        if shutil.which("docker") is None:
            self.logger.error("Docker CLI not found in PATH. Install Docker Desktop/CLI first.")
            raise SystemExit(1)

        if not self.env.workspace.exists():
            self.logger.error(
                "Hibernate workspace not found: "
                f"{self.env.workspace} (resolved from WORKSPACE_DIR={self.env.workspace_root})"
            )
            self.logger.info("Run local-setup.md to initialize the workspace.")
            raise SystemExit(1)

        if not self.env.verify_project_dir.exists():
            self.logger.error(f"Verification project missing: {self.env.verify_project_dir}")
            raise SystemExit(1)

        self._ensure_tidb_container()

        self.gradle_root = self._find_gradle_root()
        self.logger.info(f"Using Gradle wrapper at: {self.gradle_root / 'gradlew'}")

        if self.options.bootstrap_sql:
            resolved = self.options.bootstrap_sql.expanduser().resolve()
            if not resolved.exists():
                self.logger.error(f"Bootstrap SQL file not found: {resolved}")
                raise SystemExit(1)
            self.bootstrap_sql = resolved
            self.logger.info(f"Including bootstrap SQL: {resolved}")

    def run_verification(self) -> None:
        assert self.gradle_root is not None
        gradle_root = self.gradle_root

        runner_image = self.env.runner_image
        docker_cmd = [
            "docker",
            "run",
            "--rm",
            "--network",
            f"container:{self.env.tidb_container}",
            "-v",
            f"{self.env.verify_project_dir.as_posix()}:/verification",
            "-v",
            f"{gradle_root.as_posix()}:/workspace",
            "-w",
            "/verification",
        ]

        if self.bootstrap_sql:
            docker_cmd.extend(["-v", f"{self.bootstrap_sql.as_posix()}:/bootstrap.sql:ro"])

        docker_cmd.append(runner_image)

        gradle_cmd = "/workspace/gradlew --project-dir /verification --quiet --console=plain run"
        if self.bootstrap_sql:
            gradle_cmd += " --args=/bootstrap.sql"

        docker_cmd.extend(["bash", "-lc", gradle_cmd])
        self.logger.info(f"Running verification inside {runner_image} container...")
        self.runner.run(docker_cmd, check=True)

    def _ensure_tidb_container(self) -> None:
        try:
            result = self.runner.run(
                [
                    "docker",
                    "ps",
                    "--filter",
                    "name=tidb",
                    "--format",
                    "{{.Names}}",
                ],
                capture_output=True,
                check=True,
            )
        except subprocess.CalledProcessError as exc:
            self.logger.error(f"Failed to list Docker containers ({exc})")
            raise SystemExit(1) from exc

        names = {line.strip() for line in result.stdout.splitlines() if line.strip()}
        tidb_container = self.env.tidb_container
        if tidb_container not in names:
            self.logger.error(
                f"No running TiDB container detected (expected container named '{tidb_container}')."
            )
            self.logger.info(f"Start it via: cd \"{self.env.workspace}\" && ./docker_db.sh tidb")
            raise SystemExit(1)

    def _find_gradle_root(self) -> Path:
        candidates = [
            self.env.workspace / "gradlew",
            self.env.workspace / "hibernate-orm" / "gradlew",
        ]
        for candidate in candidates:
            if candidate.exists():
                return candidate.parent

        self.logger.error(
            f"Unable to locate gradlew under {self.env.workspace} (checked ./gradlew and ./hibernate-orm/gradlew)."
        )
        self.logger.info("Verify your workspace matches local-setup.md.")
        raise SystemExit(1)


def main(argv: Optional[Sequence[str]] = None) -> None:
    options = parse_options(argv)
    env = load_environment()
    orchestrator = VerifyTidbOrchestrator(options, env)
    orchestrator.execute()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nVerification interrupted by user", file=sys.stderr)
        raise SystemExit(1)
